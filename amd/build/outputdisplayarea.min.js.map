{"version":3,"file":"outputdisplayarea.min.js","sources":["../src/outputdisplayarea.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more util.details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n/**\n * A module used for running code using the Coderunner webservice (CRWS) and displaying output. Originally\n * developed for use in the Scratchpad UI. It has three modes of operation:\n * - 'text': Just display the output as text, html escaped.\n * - 'json': The recommended way to display programs that use stdin or output images (or both).\n *      - Accepts JSON in the CRWS response output with fields:\n *          - \"returncode\": Error/return code from running program.\n *          - \"stdout\": Stdout text from running program.\n *          - \"stderr\": Error text from running program.\n *          - \"files\": An object containing filenames mapped to base64 encoded images.\n *                     These will be displayed below any stdout text.\n *      - When input from stdin is required the returncode 42 should be returned, raise this\n *        any time the program asks for input. An (html) input will be added after the last stdout received.\n *        When enter is pressed, runCode is called with value of the input added to the stdin string.\n *        This repeats until returncode is no longer 42.\n * - 'html': Display program output as raw html inside the output area.\n *      - This can be used to show images and insert other HTML tags (and beyond).\n *      - Giving an <input> tag the class 'coderunner-run-input' will add an event that\n *        on pressing enter will call the runCode method again with the value of that input field added to stdin.\n *        This method of receiving stdin is harder to use but more flexible than JSON, enter at your own risk.\n *\n * @module qtype_coderunner/outputdisplayarea\n * @copyright  James Napier, 2023, The University of Canterbury\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport ajax from 'core/ajax';\nimport {get_string as getLangString} from 'core/str';\n\n\nconst ENTER_KEY = 13;\nconst INPUT_INTERRUPT = 42;\nconst RESULT_SUCCESS = 15;\nconst INPUT_CLASS = 'coderunner-run-input';\nconst JSON_DISPLAY_PROPS = ['returncode', 'stdout', 'stderr', 'files'];\n\n\n/**\n * Get the specified language string using\n * AJAX and plug it into the given textarea\n * @param {string} langStringName The language string name.\n * @param {DOMnode} node area into which the error message\n * should be plugged.\n * @param  {function} callback Callback function, with two arguments: node, message.\n * @param {string} additionalText Extra text to follow the result code.\n */\nconst setLangString = async(langStringName, node, callback, additionalText = '') => {\n    let message = await getLangString(langStringName, 'qtype_coderunner');\n    if (langStringName.includes('error')) {\n        message = \"*** \" + message + \" ***\\n\";\n    }\n    if (additionalText) {\n        message += additionalText;\n    }\n    if (callback instanceof Function) {\n        callback(node, message);\n    } else {\n        node.innerText = message;\n    }\n};\n\nconst diagnoseWebserviceResponse = (response) => {\n    // Table of error conditions.\n    // Each row is response.error, response.result, langstring\n    // response.result is ignored if response.error is non-zero.\n    // Any condition not in the table is deemed an \"Unknown runtime error\".\n    const ERROR_RESPONSES = [\n        [1, 0, 'error_access_denied'], // Sandbox AUTH_ERROR\n        [2, 0, 'error_unknown_language'], // Sandbox WRONG_LANG_ID\n        [3, 0, 'error_access_denied'], // Sandbox ACCESS_DENIED\n        [4, 0, 'error_submission_limit_reached'], // Sandbox SUBMISSION_LIMIT_EXCEEDED\n        [5, 0, 'error_sandbox_server_overload'], // Sandbox SERVER_OVERLOAD\n        [0, 11, ''], // RESULT_COMPILATION_ERROR\n        [0, 12, ''], // RESULT_RUNTIME_ERROR\n        [0, 13, 'error_timeout'], // RESULT TIME_LIMIT\n        [0, RESULT_SUCCESS, ''], // RESULT_SUCCESS\n        [0, 17, 'error_memory_limit'], // RESULT_MEMORY_LIMIT\n        [0, 21, 'error_sandbox_server_overload'], // RESULT_SERVER_OVERLOAD\n        [0, 30, 'error_excessive_output'] // RESULT OUTPUT_LIMIT\n    ];\n    for (let i = 0; i < ERROR_RESPONSES.length; i++) {\n        let row = ERROR_RESPONSES[i];\n        if (row[0] == response.error && (response.error != 0 || response.result == row[1])) {\n            return row[2];\n        }\n    }\n    return 'error_unknown_runtime'; // We're dead, Fred.\n};\n\n/**\n * Concatenates the cmpinfo, stdout and stderr fields of the sandbox\n * response, truncating both stdout and stderr to a given maximum length\n * if necessary (in which case '... (truncated)' is appended.\n * @param {object} response Sandbox response object\n */\nconst combinedOutput = (response) => {\n    return response.cmpinfo + response.output + response.stderr;\n};\n\n/**\n * Check whether obj has the properties in props, returns missing properties.\n * @param {object} obj to check properties of\n * @param {array} props to check for.\n * @returns {array} of missing properties.\n */\nconst missingProperties = (obj, props) => {\n    return props.filter(prop => !obj.hasOwnProperty(prop));\n};\n\n/**\n * Insert a base64 encoded string into HTML image.\n * @param {string} base64 encoded string.\n * @param {string} type of encoded image file.\n * @returns {*|jQuery|HTMLElement} image tag containing encoded image from string.\n */\nconst getImage = (base64, type = 'png') => {\n    const image = document.createElement('img');\n    image.src = `data:image/${type};base64,${base64}`;\n    return image;\n};\n\n/**\n * Constructor for OutputDisplayArea object. For use with the output_displayarea template.\n * @param {string} displayAreaId The id of the display area div, this should match the 'id'\n * from the template.\n * @param {string} outputMode The mode being used for output, must be text, html or json.\n * @param {string} lang The language to run code with.\n * @param {string} sandboxParams The sandbox params to run code with.\n */\nclass OutputDisplayArea {\n    constructor(displayAreaId, outputMode, lang, sandboxParams) {\n        this.displayAreaId = displayAreaId;\n        this.lang = lang;\n        this.mode = outputMode;\n        this.sandboxParams = sandboxParams;\n\n        this.textDisplay = document.getElementById(displayAreaId + '-text');\n        this.imageDisplay = document.getElementById(displayAreaId + '-images');\n\n        this.prevRunSettings = null;\n    }\n\n    /**\n     * Clear the display of any images and text.\n     */\n    clearDisplay() {\n        this.textDisplay.innerHTML = \"\";\n        this.imageDisplay.innerHTML = \"\";\n    }\n\n    /**\n     * Display text from a CRWS response to the display (escaped).\n     * @param {object} response Coderunner webservice response JSON.\n     */\n    displayText(response) {\n        this.textDisplay.innerText = combinedOutput(response);\n    }\n\n    /**\n     * Display HTML from a CRWS response to the display (un-escaped).\n     * Find the first HTML input element with the input class and\n     * add event listeners to handle reading stdin.\n     * @param {object} response Coderunner webservice response JSON,\n     * with output field containing HTML.\n     */\n    displayHtml(response) {\n        this.textDisplay.innerHTML = combinedOutput(response);\n        const inputEl = this.textDisplay.querySelector('.' + INPUT_CLASS);\n        if (inputEl) {\n            this.addInputEvents(inputEl);\n        }\n    }\n\n    /**\n     * Display JSON from a CRWS response to the display.\n     * Assumes response.output will be a JSON with the fields:\n     *      - \"returncode\": Error/return code from running program.\n     *      - \"stdout\": Stdout text from running program.\n     *      - \"stderr\": Error text from running program.\n     *      - \"files\": An object containing filenames mapped to base64 encoded images.\n     *                 These will be displayed below any stdout text.\n     * NOTE: See file header/readme for more info.\n     * @param {object} response Coderunner webservice response JSON,\n     * with output field containing JSON string.\n     */\n    displayJson(response) {\n        const result = this.validateJson(response.output);\n\n        let text = result.stdout;\n\n        if (result.returncode !== INPUT_INTERRUPT) {\n            text += result.stderr;\n        }\n        if (result.returncode == 13) { // Timeout\n            setLangString('error_timeout', this.textDisplay, (node, msg) => {\n             node.innerText += msg;\n            });\n        }\n\n        const numImages = this.displayImages(result.files);\n        if (text.trim() === '' && result.returncode !== INPUT_INTERRUPT) {\n            if (numImages == 0) {\n                this.displayNoOutput(null);\n            }\n        } else {\n            this.textDisplay.innerText = text;\n        }\n        if (result.returncode === INPUT_INTERRUPT) {\n            this.addInput();\n        }\n    }\n\n    /**\n     * Validate JSON to display, make sure it is valid json and has required fields.\n     * @param {string} jsonString string of JSON to be displayed.\n     * @returns {object} JSON as object\n     */\n    validateJson(jsonString) {\n        let result = null;\n        try {\n            result = JSON.parse(jsonString);\n        } catch (e) {\n            window.alert(\n                `Error parsing display JSON output: \\n` +\n                `'${jsonString}\\n'` +\n                `Error Msg: \\n` +\n                ` ${e.message} \\n` +\n                `The question author must fix this!`\n            );\n        }\n\n        const missing = missingProperties(result, JSON_DISPLAY_PROPS);\n        if (missing.length > 0) {\n            window.alert(\n                `Display JSON (in response.result) is missing the following fields: \\n` +\n                `${missing.join()} \\n` +\n                `The question author must fix this!`\n            );\n        }\n        return result;\n    }\n\n    /**\n     * Display no output message if no output to display or response is null.\n     * @param {object} response Coderunner webservice response JSON, set to null to force\n     * display of no output message.\n     */\n    displayNoOutput(response) {\n        const isNoOutput = response ? combinedOutput(response).length === 0 : true;\n        if (isNoOutput || response === null) {\n            const span = document.createElement('span');\n            span.style.color = 'red';\n            setLangString('nooutput', span);\n            this.clearDisplay();\n            this.textDisplay.append(span);\n        }\n        return isNoOutput;\n    }\n    /**\n     * Display response using the current display mode.\n     * @param {object} response Coderunner webservice response JSON.\n     */\n    display(response) {\n        const error = diagnoseWebserviceResponse(response);\n        if (error !== '') {\n            setLangString(error, this.textDisplay);\n            return;\n        }\n        if (this.displayNoOutput(response)) {\n            return;\n        }\n\n        if (this.mode === 'json') {\n            this.displayJson(response);\n        } else if (this.mode === 'html') {\n            this.displayHtml(response);\n        } else if (this.mode === 'text') {\n            this.displayText(response);\n        } else {\n            throw Error(`Invalid outputMode given: \"${this.mode}\"`);\n        }\n    }\n\n    /**\n     * Run code using the Coderunner webservice and then display the output\n     * using the selected mode. This function uses AJAX to asynchronously run and\n     * display code.\n     * @param {string} code to be run.\n     * @param {string} stdin to be fed into the program.\n     * @param {boolean} shouldClearDisplay will reset the display before displaying.\n     * Use false when doing stdin runs.\n     */\n    runCode(code, stdin, shouldClearDisplay = false) {\n        this.prevRunSettings = [code, stdin];\n        if (shouldClearDisplay) {\n            this.clearDisplay();\n        }\n        ajax.call([{\n            methodname: 'qtype_coderunner_run_in_sandbox',\n            args: {\n                contextid: M.cfg.contextid, // Moodle context ID\n                sourcecode: code,\n                language: this.lang,\n                stdin: stdin,\n                params: JSON.stringify(this.sandboxParams) // Sandbox params\n            },\n            done: (responseJson) => {\n                const response = JSON.parse(responseJson);\n                this.display(response);\n            },\n            fail: (error) => {\n                alert(error.message);\n            }\n        }]);\n    }\n\n    /**\n     * Add an input field with event listeners to support running again\n     * with new stdin entered by user.\n     */\n    addInput() {\n        const inputId = `${this.displayAreaId}-input-field`;\n        this.textDisplay.innerHTML += `<input type=\"text\" id=\"${inputId}\" class=\"${INPUT_CLASS}\">`;\n        const inputEl = document.getElementById(inputId);\n        setLangString('enter_to_submit', inputEl, (node, msg) => {\n            node.placeholder += msg;\n        });\n        this.addInputEvents(inputEl);\n    }\n\n    /**\n     * Add event listeners to inputEl overriding enter key to:\n     *  - Prevent form-submit.\n     *  - Call runCode again, adding value in inputEl to stdin.\n     * @param {node} inputEl to add event listeners to.\n     */\n    addInputEvents(inputEl) {\n        inputEl.focus();\n\n        inputEl.addEventListener('keydown', (e) => {\n            if (e.keyCode === ENTER_KEY) {\n                e.preventDefault(); // Do NOT form submit.\n            }\n        });\n        inputEl.addEventListener('keyup', (e) => {\n            if (e.keyCode === ENTER_KEY) {\n                const line = inputEl.value;\n                inputEl.remove();\n                this.textDisplay.innterHTML += line; // Perhaps this should be sanitized.\n                this.prevRunSettings[1] += line + '\\n';\n                this.runCode(...this.prevRunSettings, false);\n            }\n        });\n    }\n\n    /**\n     * Take the files from a JSON response and display them.\n     * @param {object} files from response, in filename: filecontents pairs.\n     * @returns {number} number of images displayed.\n     */\n    displayImages(files) {\n        let numImages = 0;\n        for (const [fname, fcontents] of Object.entries(files)) {\n            const fileType = fname.split('.')[1];\n            if (fileType) {\n                const image = getImage(fcontents, fileType);\n                this.imageDisplay.append(image);\n                numImages += 1;\n            } else {\n                window.alert(`Could not read filename correctly: \"${fname}\"`);\n            }\n        }\n        return numImages;\n    }\n}\n\n\nexport {\n    OutputDisplayArea\n};\n"],"names":["JSON_DISPLAY_PROPS","setLangString","langStringName","node","callback","additionalText","message","includes","Function","innerText","combinedOutput","response","cmpinfo","output","stderr","getImage","base64","type","image","document","createElement","src","OutputDisplayArea","displayAreaId","outputMode","lang","sandboxParams","mode","textDisplay","getElementById","imageDisplay","prevRunSettings","innerHTML","inputEl","this","querySelector","addInputEvents","result","validateJson","text","stdout","returncode","msg","numImages","displayImages","files","trim","displayNoOutput","addInput","jsonString","JSON","parse","e","window","alert","missing","obj","props","filter","prop","hasOwnProperty","missingProperties","length","join","isNoOutput","span","style","color","clearDisplay","append","error","ERROR_RESPONSES","i","row","diagnoseWebserviceResponse","displayJson","displayHtml","Error","displayText","code","stdin","shouldClearDisplay","call","methodname","args","contextid","M","cfg","sourcecode","language","params","stringify","done","responseJson","_this","display","fail","inputId","placeholder","focus","addEventListener","keyCode","preventDefault","line","value","remove","_this2","innterHTML","runCode","Object","entries","fname","fcontents","fileType","split"],"mappings":"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"}